// frontend/src/services/orderBookAnalyzer.js

/**
 * OrderBookAnalyzer
 * خدمة لتحليل دفتر الطلبات وإنتاج إحصائيات مفيدة لواجهة التداول فقط (Frontend).
 *
 * متوقَّع أن تستقبل بيانات بالصورة:
 * {
 *   symbol: 'BTCUSDT',
 *   bids: [[price, quantity], ...] أو [{ price, quantity }, ...],
 *   asks: [[price, quantity], ...] أو [{ price, quantity }, ...]
 * }
 */
class OrderBookAnalyzer {
  constructor(options = {}) {
    this.maxDepth = options.maxDepth || 50;
    this.defaultSymbol = options.defaultSymbol || 'BTCUSDT';
  }

  /**
   * تحليل دفتر الأوامر
   * @param {object} orderBookData
   * @returns {object} stats
   */
  analyzeOrderBook(orderBookData = {}) {
    const symbol = orderBookData.symbol || this.defaultSymbol;

    const bids = this._normalizeSide(orderBookData.bids, true).slice(
      0,
      this.maxDepth,
    );
    const asks = this._normalizeSide(orderBookData.asks, false).slice(
      0,
      this.maxDepth,
    );

    const bestBid = bids.length ? bids[0].price : null;
    const bestAsk = asks.length ? asks[0].price : null;

    const midPrice = this._calculateMidPrice(bestBid, bestAsk);
    const { spreadValue, spreadPercent } = this._calculateSpread(
      bestBid,
      bestAsk,
      midPrice,
    );

    const {
      totalVolume: totalBidVolume,
      cumulative: bidCumulative,
    } = this._calculateCumulativeVolume(bids);

    const {
      totalVolume: totalAskVolume,
      cumulative: askCumulative,
    } = this._calculateCumulativeVolume(asks);

    const depthImbalance = this._calculateImbalance(
      totalBidVolume,
      totalAskVolume,
    );
    const marketPressure = this._classifyPressure(depthImbalance);

    return {
      symbol,
      bestBid,
      bestAsk,

      midPrice: midPrice != null ? this._formatPrice(midPrice) : null,
      rawMidPrice: midPrice,

      spread: spreadValue != null ? this._formatPrice(spreadValue) : null,
      spreadValue,
      spreadPercent,
      spreadText:
        spreadValue != null && spreadPercent != null
          ? `${this._formatPrice(spreadValue)} (${spreadPercent.toFixed(
              3,
            )}%)`
          : null,

      totalBidVolume,
      totalAskVolume,
      bidLevels: bids.length,
      askLevels: asks.length,
      bidCumulative,
      askCumulative,

      depthImbalance,
      marketPressure,
    };
  }

  _normalizeSide(sideData, isBid) {
    if (!Array.isArray(sideData)) return [];

    const normalized = sideData
      .map((entry) => {
        if (!entry) return null;

        if (Array.isArray(entry)) {
          const [price, quantity] = entry;
          return {
            price: parseFloat(price),
            quantity: parseFloat(quantity),
          };
        }

        if (typeof entry === 'object') {
          const price = parseFloat(entry.price ?? entry[0]);
          const quantity = parseFloat(entry.quantity ?? entry.qty ?? entry[1]);
          return { price, quantity };
        }

        return null;
      })
      .filter(
        (item) =>
          item &&
          Number.isFinite(item.price) &&
          Number.isFinite(item.quantity) &&
          item.quantity > 0,
      );

    // bids: من الأعلى إلى الأدنى – asks: من الأدنى إلى الأعلى
    normalized.sort((a, b) => (isBid ? b.price - a.price : a.price - b.price));

    return normalized;
  }

  _calculateMidPrice(bestBid, bestAsk) {
    if (!Number.isFinite(bestBid) || !Number.isFinite(bestAsk)) return null;
    return (bestBid + bestAsk) / 2;
  }

  _calculateSpread(bestBid, bestAsk, midPrice) {
    if (!Number.isFinite(bestBid) || !Number.isFinite(bestAsk)) {
      return { spreadValue: null, spreadPercent: null };
    }
    const spreadValue = Math.max(0, bestAsk - bestBid);
    const spreadPercent =
      midPrice && midPrice > 0 ? (spreadValue / midPrice) * 100 : null;
    return { spreadValue, spreadPercent };
  }

  _calculateCumulativeVolume(levels) {
    let totalVolume = 0;
    const cumulative = [];

    levels.forEach((level, index) => {
      totalVolume += level.quantity;
      cumulative.push({
        index,
        price: level.price,
        quantity: level.quantity,
        cumulativeVolume: totalVolume,
      });
    });

    return { totalVolume, cumulative };
  }

  _calculateImbalance(totalBidVolume, totalAskVolume) {
    const b = Number(totalBidVolume) || 0;
    const a = Number(totalAskVolume) || 0;
    const denom = b + a;
    if (denom === 0) return 0;
    // بين -1 و +1 (قريب من +1 = ضغط شرائي)
    return (b - a) / denom;
  }

  _classifyPressure(imbalance) {
    if (!Number.isFinite(imbalance)) return 'neutral';
    if (imbalance > 0.2) return 'bullish';
    if (imbalance < -0.2) return 'bearish';
    return 'neutral';
  }

  _formatPrice(value, decimals = 4) {
    if (!Number.isFinite(value)) return null;
    const abs = Math.abs(value);
    if (abs >= 1000) return value.toFixed(2);
    if (abs >= 1) return value.toFixed(4);
    return value.toFixed(decimals);
  }
}

export default OrderBookAnalyzer;
